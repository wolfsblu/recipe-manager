// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package database

import (
	"context"
	"time"
)

const createPasswordResetToken = `-- name: CreatePasswordResetToken :one
INSERT INTO password_resets (user_id, token)
VALUES (?, ?)
RETURNING user_id, token, created_at
`

type CreatePasswordResetTokenParams struct {
	UserID int64
	Token  string
}

func (q *Queries) CreatePasswordResetToken(ctx context.Context, arg CreatePasswordResetTokenParams) (PasswordReset, error) {
	row := q.db.QueryRowContext(ctx, createPasswordResetToken, arg.UserID, arg.Token)
	var i PasswordReset
	err := row.Scan(&i.UserID, &i.Token, &i.CreatedAt)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password_hash, role_id, locale)
VALUES (?, ?, ?, ?)
RETURNING id, email, password_hash, is_confirmed, role_id, locale, created_at
`

type CreateUserParams struct {
	Email        string
	PasswordHash string
	RoleID       int64
	Locale       string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.RoleID,
		arg.Locale,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsConfirmed,
		&i.RoleID,
		&i.Locale,
		&i.CreatedAt,
	)
	return i, err
}

const createUserRegistration = `-- name: CreateUserRegistration :one
INSERT INTO user_registrations (user_id, token)
VALUES (?, ?)
RETURNING user_id, token, created_at
`

type CreateUserRegistrationParams struct {
	UserID int64
	Token  string
}

func (q *Queries) CreateUserRegistration(ctx context.Context, arg CreateUserRegistrationParams) (UserRegistration, error) {
	row := q.db.QueryRowContext(ctx, createUserRegistration, arg.UserID, arg.Token)
	var i UserRegistration
	err := row.Scan(&i.UserID, &i.Token, &i.CreatedAt)
	return i, err
}

const deletePasswordResetTokenByUserId = `-- name: DeletePasswordResetTokenByUserId :exec
DELETE
FROM password_resets
WHERE user_id = ?
`

func (q *Queries) DeletePasswordResetTokenByUserId(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deletePasswordResetTokenByUserId, userID)
	return err
}

const deletePasswordResetsBefore = `-- name: DeletePasswordResetsBefore :exec
DELETE
FROM password_resets
WHERE created_at < ?
`

func (q *Queries) DeletePasswordResetsBefore(ctx context.Context, createdAt time.Time) error {
	_, err := q.db.ExecContext(ctx, deletePasswordResetsBefore, createdAt)
	return err
}

const deleteRegistrationByUserId = `-- name: DeleteRegistrationByUserId :exec
DELETE
FROM user_registrations
WHERE user_id = ?
`

func (q *Queries) DeleteRegistrationByUserId(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteRegistrationByUserId, userID)
	return err
}

const deleteRegistrationsBefore = `-- name: DeleteRegistrationsBefore :exec
DELETE
FROM users
WHERE created_at < ?
`

func (q *Queries) DeleteRegistrationsBefore(ctx context.Context, createdAt time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteRegistrationsBefore, createdAt)
	return err
}

const getPasswordResetToken = `-- name: GetPasswordResetToken :one
SELECT password_resets.user_id, password_resets.token, password_resets.created_at, users.id, users.email, users.password_hash, users.is_confirmed, users.role_id, users.locale, users.created_at
FROM password_resets
         INNER JOIN users ON users.id = password_resets.user_id
WHERE token = ?
LIMIT 1
`

type GetPasswordResetTokenRow struct {
	PasswordReset PasswordReset
	User          User
}

func (q *Queries) GetPasswordResetToken(ctx context.Context, token string) (GetPasswordResetTokenRow, error) {
	row := q.db.QueryRowContext(ctx, getPasswordResetToken, token)
	var i GetPasswordResetTokenRow
	err := row.Scan(
		&i.PasswordReset.UserID,
		&i.PasswordReset.Token,
		&i.PasswordReset.CreatedAt,
		&i.User.ID,
		&i.User.Email,
		&i.User.PasswordHash,
		&i.User.IsConfirmed,
		&i.User.RoleID,
		&i.User.Locale,
		&i.User.CreatedAt,
	)
	return i, err
}

const getPasswordResetTokenByUser = `-- name: GetPasswordResetTokenByUser :one
SELECT user_id, token, created_at
FROM password_resets
WHERE user_id = ?
LIMIT 1
`

func (q *Queries) GetPasswordResetTokenByUser(ctx context.Context, userID int64) (PasswordReset, error) {
	row := q.db.QueryRowContext(ctx, getPasswordResetTokenByUser, userID)
	var i PasswordReset
	err := row.Scan(&i.UserID, &i.Token, &i.CreatedAt)
	return i, err
}

const getPermissionsByRole = `-- name: GetPermissionsByRole :many
SELECT permissions.id, permissions.name, permissions.slug
FROM permissions
INNER JOIN role_permissions ON permissions.id = role_permissions.permission_id
WHERE role_permissions.role_id = ?
`

type GetPermissionsByRoleRow struct {
	ID   int64
	Name string
	Slug string
}

func (q *Queries) GetPermissionsByRole(ctx context.Context, roleID int64) ([]GetPermissionsByRoleRow, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionsByRole, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPermissionsByRoleRow
	for rows.Next() {
		var i GetPermissionsByRoleRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Slug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT users.id, users.email, users.password_hash, users.is_confirmed, users.role_id, users.locale, users.created_at,
       roles.name as role_name
FROM users
INNER JOIN roles ON users.role_id = roles.id
WHERE users.id = ?
LIMIT 1
`

type GetUserRow struct {
	ID           int64
	Email        string
	PasswordHash string
	IsConfirmed  bool
	RoleID       int64
	Locale       string
	CreatedAt    time.Time
	RoleName     string
}

func (q *Queries) GetUser(ctx context.Context, id int64) (GetUserRow, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i GetUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsConfirmed,
		&i.RoleID,
		&i.Locale,
		&i.CreatedAt,
		&i.RoleName,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, is_confirmed, role_id, locale, created_at
FROM users
WHERE email = ?
LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsConfirmed,
		&i.RoleID,
		&i.Locale,
		&i.CreatedAt,
	)
	return i, err
}

const getUserRegistration = `-- name: GetUserRegistration :one
SELECT user_registrations.user_id, user_registrations.token, user_registrations.created_at, users.id, users.email, users.password_hash, users.is_confirmed, users.role_id, users.locale, users.created_at
FROM user_registrations
         INNER JOIN users ON users.id = user_registrations.user_id
WHERE token = ?
LIMIT 1
`

type GetUserRegistrationRow struct {
	UserRegistration UserRegistration
	User             User
}

func (q *Queries) GetUserRegistration(ctx context.Context, token string) (GetUserRegistrationRow, error) {
	row := q.db.QueryRowContext(ctx, getUserRegistration, token)
	var i GetUserRegistrationRow
	err := row.Scan(
		&i.UserRegistration.UserID,
		&i.UserRegistration.Token,
		&i.UserRegistration.CreatedAt,
		&i.User.ID,
		&i.User.Email,
		&i.User.PasswordHash,
		&i.User.IsConfirmed,
		&i.User.RoleID,
		&i.User.Locale,
		&i.User.CreatedAt,
	)
	return i, err
}

const updatePasswordByUserId = `-- name: UpdatePasswordByUserId :exec
UPDATE users
SET password_hash = ?
WHERE id = ?
`

type UpdatePasswordByUserIdParams struct {
	PasswordHash string
	ID           int64
}

func (q *Queries) UpdatePasswordByUserId(ctx context.Context, arg UpdatePasswordByUserIdParams) error {
	_, err := q.db.ExecContext(ctx, updatePasswordByUserId, arg.PasswordHash, arg.ID)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET email        = ?,
    is_confirmed = ?
WHERE id = ?
`

type UpdateUserParams struct {
	Email       string
	IsConfirmed bool
	ID          int64
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser, arg.Email, arg.IsConfirmed, arg.ID)
	return err
}
